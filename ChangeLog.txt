v1.00.01	2025_03_17	This is my first attempt at flat buttons with rounded corners.  They are flat but there is an issue with the rounded corners when I try to use a different fill color you can see the corners..they are no longer transparent.
v1.00.01	2025_03_17	I'm going to create a new app that uses the 'CreateRoundRectRgn' to fix the issue with the corners showing when I fill the rectangle with a color.
v1.00.01	2025_03_17	Added a third button that uses a bitmap
v1.00.01	2025_03_26	Added info to the manifest to ensure that version 6 of the Windows Common Controls are loaded.  These are needed for Theme Awareness
v1.00.01	2025_04_03	Found the issue with the tab key not moving focus.  Issue was with 'if (!IsDialogMessage(hWnd, &msg))'.  Needs to be 'hWnd' not 'hwnd'. hWnd is the handle to the main window for the app.  Probably should rename it to 'hMainWindow'
v1.00.01	2025_04_03	To Fix the tab key focus issue I also have to declare 'HWNDD hWnd' as a global variable so that it was in scope for the '!IsDialogMessage(hWnd, &msg)' call.
v1.00.01	2025_04_06	The next 3 lines all relate to how I solved an issue with finding one place in the main winproc to detect when buttons were receiving or losing focus.
v1.00.01	2025_04_06	The MS Windows documentation states that if BS_OWNERDRAW button style is used that you should NOT use any other BS styles.  I've found this to be wrong.  If you want to receive WM_COMMAND/BN_SETFOCUS and WM_COMMAND/BN_KILLFOCUS messages you can add 'BS_NOTIFY' along with BS_OWNERDRAW styles when creating your buttons. 
v1.00.01	2025_04_06	Found the I can use BS_NOTIFY along with my BS_OWNERDRAW button styels when creating buttons and I will then get 'WM_COMMAND/BN_SETFOCUS and BN_KILLFOCUS messages. This allows you to have one place to code for focus even if you have a mix of OWNERDRAW and non OWNERDRAW buttons as well as a mix of standard and subclassed buttons.
v1.00.01	2025_04_06	NOTE: That subclassed buttons can use the WM_SETFOCUS and WM_KILLFOCUS messages in their subclassed message pumps but it's easier if you want to have one place for focus code to add 'BS_NOTIFY' to all your buttons and look in one place...the main windowproc's WM_COMMAND/BN_SETFOCUS BN_KILLFOCUS messages.
v1.00.01	2025_04_07	Used StretchBlt instead of BitBlt to resize the Button6 background image to fit nicely in the button.
v1.00.01	2025_04_07	Created a StatusBar at the bottom of the main app window.  Use 'SetWindowText' to update the text.  I found issues using 'SendMessageA' (text looked like Chinese).
v1.00.01	2025_04_08	Found way to highlight subclassed ownerdraw buttons	when the mouse is over them.  In the WM_MOUSEMOVE message for both the parent and the subclassed message pumps I set a variable 'controlUnderMouse' to the controlID of the control under the mouse.  I only update this variable when it changes.  Can used that event to highlight the background of the control or whatever visual change you want to occur.
v1.00.01	2025_04_08	Found that you have to be careful using 'hWnd' for everything (like your main app window).  For example, if in your subclassed message pump in the WM_MOUSEMOVE event, you try to update the main windows statusbar control using 'SetWindowText(GetDlgItem(hwnd, IDC_STATUSBAR), L"Some Text";'.  It won't work because 'hWnd' points to one of your subclassed buttons that the mouse is over... not the main app window.  You have to use 'GetParent' to get the main windows handle.  Like this...  'SetWindowText(GetDlgItem(GetParent(hWnd),IDC_STATUSBAR), L"Some Text"';
v1.00.01	2025_04_08	Given the issue described in line 14 (above) it may be better to create a global variable for your main window's handle and name it something like 'hwndMain'.  Avoid using 'hWnd' for your main window's handle as this can get confusing since so much of the time 'hWind' is used in the main window pump (WndProc) and also in subclassed control message pumps.
v1.00.01	2025_04_08	Found that it may be smart to create global variables for the main window handle (use hwndMain) and for controls that you will be referencing frequently like a statusbar (use hwndStatusBar).  This way you can minimize the number of times you need to use 'GetParent' or GetDlgItem.
v1.00.01	2025_04_08	Found how to use 'SelectFont' to select font settings 'INTO' an hdc (device context) which is needed for ownerdraw subclassed button controls.  Can't use 'SendMessage(hWndControl, WM_SETFONT, (WPARAM)hFont, TRUE);' in the subclass message pump WM_PAINT event as it will create a circle of WM_PAINT messages (infinite loop).
v1.00.01	2025_04_09	Found that using DrawText to update a buttons text (for Ownerdraw Subclassed buttons) doesn't update the WindowText of the button...meaning that if you use GetWindowText you will not get the text you wrote using the DrawText function.  You'll get the original WindowText that was used when the control was created.  This is because DrawText is 'drawing' the text on the controls device context (hdc).  To overcome this issue I'm not updating the controls WindowText (using SetWindowText) every time I use DrawText.  This was they stay in sync.	
v1.00.01	2025_04_10	Created a struct (ControlProps) and a map (ButtonProps) to store default properties to be used by the DrawControl function when no parameters are passed.  This will allow a button to be redrawn even if the call to DrawControl only passes the 'ButtonText' parameter.  The background bitmap and the font color, size and style can be pulled from the ButtonProps map.  This will make it easy for the calling routine because it only needs to specify what it wants to change and the things that should stay the same don't need to be specified...and maybe they aren't even know to the calling routine.
v1.00.01	2025_04_10	To make ButtonProps/DrawControl work properly I'm thinking that each time DrawControl is called it will update ButtonProps with the bitmap/font/color/text etc that it uses.  That way the next time DrawControl is called ButtonProps is up to date as to how the button looks.  I'm not 100 percent sure this is the way to go because we're calling some of the props 'Default' instead of 'Current'.  What I'm describing is really 'Current'...not default.  Need to hash this out in my head. 
v1.00.01	2025_04_11	Added a few more params to the DrawControl function such as textColor, fontWeight.  Refactored my button event code to use DrawControl which greatly simplified it.
v1.00.01	2025_04_12	Fixed issue where if I put the mouse over Button1 to highlight it, then hit tab until Button3 got focus the code would enter an infinite loop.  Button1 and 6 would flicker.  Found issue was because I needed a break statement in the WM_NOTIFY code that was before my WM_MOUSEMOVE code.  In my WM_MOUSEMOVE code it was thinking that the mouse was now over a new control and it was calling DrawControl over and over.
v1.00.01	2025_04_12	NOTE:  Need to be very careful about where 'break' statements are needed in switch/case blocks especially because there are several nested switch/case statements.  I have been including 'break' inside a case and in the default part but not outside the closing '}' of the case.  This has been causing the code to fall through to the code for a second windows message or possibly a third.  
v1.00.01	2025_04_13	Added a new dialog IDD_DEBUG_VIEWER.  Idea is to copy/paste a winproc message from the output window and when you clock the IDC_DEBUG_DETAILS button it will display additional info about the message (looking up wParam/lParam info).  This can be useful for WM_COMMAND and WM_NOTIFY messages or for displaying DRAWITEMSTRUCs
v1.00.01	2025_04_16	Ran into an interesting problem when coding the 'ExpandDebugMsg' function.  This line 'wstring dateTime = mapDebugMsg[0];' was not returning a value.  Finally realized the the int variable I was using when I stored a new key/value pair into the map had not been initialized.  The first clue was when I used a 'watch' on the map.  I noticed that the key value for each pair was a long hex value.  Not 0, 1, 2 etc as would be expected. Once I intialized the int variable to 0 (zero) everything worked fine.
TODO:	Not getting BN_CLICKED or WN_LBUTTONDOWN messages logged to the output window.  BN_CLICKED is firing under WM_COMMAND...probably just seeing WM_COMMAND getting logged.  Should fix this.